#!/usr/bin/env python3
# === BTC MM ALERT ENGINE (HYBRID + SETUPS) ===
# Binance: price + funding + klines
# Bybit: OI history -> OIÎ”(15m)
# Adds: SETUP alerts (sweep/reclaim, breakout-fail, mean-revert) gated by MM regime
#
# ENV:
#   SYMBOL=BTCUSDT
#   INTERVAL_SEC=30
#   TELEGRAM_BOT_TOKEN=...
#   TELEGRAM_CHAT_ID=...
#   STATE_PATH=./state.json
#   SETUP_COOLDOWN_SEC=600   # 10m default

import os
import time
import json
import math
import random
import logging
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
log = logging.getLogger("btc-alerts")

SYMBOL = os.getenv("SYMBOL", "BTCUSDT").upper()
INTERVAL_SEC = int(os.getenv("INTERVAL_SEC", "30"))
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "").strip()

# -------------------- TELEGRAM (2 channels) --------------------
# TELEGRAM_CHAT_ID         -> Market regime channel
# TELEGRAM_SIGNALS_CHAT_ID -> Signals channel (optional; fallback to TELEGRAM_CHAT_ID)

def tg_send(chat_id: str, text: str) -> None:
    if not TELEGRAM_BOT_TOKEN or not chat_id:
        return
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    code, body = post_form(url, {"chat_id": chat_id, "text": text}, timeout=20)
    if code != 200:
        log.warning(f"Telegram send failed HTTP {code}: {str(body)[:200]}")

def send_regime(text: str) -> None:
    tg_send(TELEGRAM_CHAT_ID, text)

def send_signal(text: str) -> None:
    chat = TELEGRAM_SIGNALS_CHAT_ID or TELEGRAM_CHAT_ID
    tg_send(chat, text)

# --------------------------------------------------------------

TELEGRAM_SIGNALS_CHAT_ID = os.getenv("TELEGRAM_SIGNALS_CHAT_ID", "").strip()
STATE_PATH = os.getenv("STATE_PATH", "./state.json")
SETUP_COOLDOWN_SEC = int(os.getenv("SETUP_COOLDOWN_SEC", "600"))

BINANCE_FAPI = "https://fapi.binance.com"
BYBIT_API = "https://api.bybit.com"

# ----------------------------
# HTTP session with retry
# ----------------------------
def make_session() -> requests.Session:
    s = requests.Session()
    retry = Retry(
        total=8, connect=8, read=8, status=8,
        backoff_factor=0.7,
        status_forcelist=(429, 500, 502, 503, 504),
        allowed_methods=("GET", "POST"),
        raise_on_status=False,
        respect_retry_after_header=True,
    )
    adapter = HTTPAdapter(max_retries=retry, pool_connections=20, pool_maxsize=20)
    s.mount("https://", adapter)
    s.mount("http://", adapter)
    s.headers.update({
        "User-Agent": "btc-alerts/1.2 (+systemd; requests)",
        "Accept": "application/json,text/plain,*/*",
        "Connection": "keep-alive",
    })
    return s

SESSION = make_session()

def fetch_json(url: str, params: Optional[Dict[str, Any]] = None, timeout: float = 12.0, max_tries: int = 3) -> Optional[Any]:
    for attempt in range(1, max_tries + 1):
        try:
            r = SESSION.get(url, params=params, timeout=timeout)
            if r.status_code >= 400:
                log.warning(f"HTTP {r.status_code} GET {url}")
                if r.status_code not in (429, 500, 502, 503, 504):
                    return None
            return r.json()
        except (requests.exceptions.Timeout,
                requests.exceptions.ConnectionError,
                requests.exceptions.ChunkedEncodingError,
                requests.exceptions.ContentDecodingError) as e:
            wait = min(30.0, (2 ** (attempt - 1)) + random.random())
            log.warning(f"NET error (try {attempt}/{max_tries}) {type(e).__name__}: {e} | sleep {wait:.1f}s")
            time.sleep(wait)
        except ValueError:
            log.warning(f"Bad/non-JSON response from {url}")
            return None
        except Exception as e:
            log.exception(f"Unexpected GET error {url}: {e}")
            return None
    return None

def post_form(url: str, data: Dict[str, Any], timeout: float = 12.0) -> Tuple[int, str]:
    try:
        r = SESSION.post(url, data=data, timeout=timeout)
        return int(r.status_code), (r.text or "")
    except Exception as e:
        return 0, str(e)

# ----------------------------
# Telegram
# ----------------------------

# ----------------------------
# State
# ----------------------------
def load_state() -> Dict[str, Any]:
    try:
        with open(STATE_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

def save_state(state: Dict[str, Any]) -> None:
    try:
        with open(STATE_PATH, "w", encoding="utf-8") as f:
            json.dump(state, f, ensure_ascii=False, indent=2)
    except Exception as e:
        log.warning(f"Failed to save state: {e}")

# ----------------------------
# Helpers
# ----------------------------
def safe_float(v: Any, default: float = float("nan")) -> float:
    try:
        return float(v)
    except Exception:
        return default

def fmt_int(x: float) -> str:
    return f"{int(round(x)):,}".replace(",", " ")

def fmt_pct(x: float) -> str:
    return f"{x:+.2f}%"

# ----------------------------
# Binance: premiumIndex + klines
# ----------------------------
def binance_premium_index(symbol: str) -> Optional[Dict[str, Any]]:
    return fetch_json(f"{BINANCE_FAPI}/fapi/v1/premiumIndex", params={"symbol": symbol})

def binance_klines(symbol: str, interval: str, limit: int) -> Optional[List[List[Any]]]:
    data = fetch_json(f"{BINANCE_FAPI}/fapi/v1/klines", params={"symbol": symbol, "interval": interval, "limit": limit})
    return data if isinstance(data, list) else None

def px_change_15m_from_1m(kl_1m: List[List[Any]]) -> Optional[float]:
    if len(kl_1m) < 20:
        return None
    close_now = safe_float(kl_1m[-1][4])
    close_15m = safe_float(kl_1m[-16][4])
    if close_now <= 0 or close_15m <= 0:
        return None
    return (close_now / close_15m - 1.0) * 100.0

def atr_from_15m(kl_15m: List[List[Any]], period: int = 14) -> Optional[float]:
    if len(kl_15m) < period + 2:
        return None
    highs = [safe_float(k[2]) for k in kl_15m]
    lows = [safe_float(k[3]) for k in kl_15m]
    closes = [safe_float(k[4]) for k in kl_15m]
    trs: List[float] = []
    for i in range(1, len(kl_15m)):
        h, l, pc = highs[i], lows[i], closes[i - 1]
        tr = max(h - l, abs(h - pc), abs(l - pc))
        trs.append(tr)
    recent = trs[-period:]
    return (sum(recent) / len(recent)) if recent else None

# ----------------------------
# Bybit: OI history -> OIÎ”(15m)
# ----------------------------
def bybit_oi_delta_15m(symbol: str) -> Optional[float]:
    url = f"{BYBIT_API}/v5/market/open-interest"
    params = {"category": "linear", "symbol": symbol, "intervalTime": "5min", "limit": 4}
    data = fetch_json(url, params=params, timeout=12)
    if not isinstance(data, dict):
        return None
    result = data.get("result", {})
    lst = result.get("list", None)
    if not isinstance(lst, list) or len(lst) < 2:
        return None
    rows: List[Tuple[int, float]] = []
    for it in lst:
        if not isinstance(it, dict):
            continue
        ts_raw = it.get("timestamp", it.get("time"))
        oi_raw = it.get("openInterest", it.get("open_interest", it.get("oi")))
        ts = int(safe_float(ts_raw, default=float("nan"))) if ts_raw is not None else None
        oi = safe_float(oi_raw)
        if ts is None or math.isnan(oi):
            continue
        rows.append((ts, oi))
    if len(rows) < 2:
        return None
    rows.sort(key=lambda x: x[0])
    return rows[-1][1] - rows[0][1]

# ----------------------------
# Zones
# ----------------------------
@dataclass
class Zones:
    upper_lo: float
    upper_hi: float
    lower_lo: float
    lower_hi: float
    width_pct: float

def compute_zones(kl_1m: List[List[Any]], atr: Optional[float], lookback_min: int = 180) -> Optional[Zones]:
    if not kl_1m:
        return None
    n = min(len(kl_1m), max(60, lookback_min))
    sample = kl_1m[-n:]
    highs = [safe_float(k[2]) for k in sample]
    lows = [safe_float(k[3]) for k in sample]
    closes = [safe_float(k[4]) for k in sample if safe_float(k[4]) > 0]
    if not closes:
        return None
    recent_high = max(highs)
    recent_low = min(lows)
    mid = closes[-1]
    pad = (atr * 0.25) if (atr and atr > 0) else 0.0
    pad = max(pad, mid * 0.0007)
    upper_hi = recent_high
    upper_lo = recent_high - pad
    lower_lo = recent_low
    lower_hi = recent_low + pad
    width = max(0.0, upper_lo - lower_hi)
    width_pct = (width / mid) * 100.0 if mid > 0 else 0.0
    return Zones(upper_lo, upper_hi, lower_lo, lower_hi, width_pct)

# ----------------------------
# Regime
# ----------------------------
def classify_regime(px15m: Optional[float], oi15m: Optional[float], width_pct: Optional[float]) -> str:
    if px15m is None or width_pct is None:
        return "UNKNOWN"
    if oi15m is None:
        if width_pct <= 0.30 and abs(px15m) <= 0.25:
            return "RANGE / CHOP (OI n/a)"
        return "TRANSITION (OI n/a)"
    if oi15m < -250 and px15m < -0.20:
        return "DELEVERAGING / LONG UNWIND"
    if oi15m < -250 and px15m > +0.20:
        return "SHORT COVER / SQUEEZE"
    if width_pct <= 0.30 and abs(px15m) <= 0.25 and abs(oi15m) <= 200:
        return "RANGE / CHOP"
    return "TRANSITION"

def norm_regime(regime_raw: str) -> str:
    r = (regime_raw or "").upper()
    if "RANGE" in r:
        return "RANGE"
    if "TRANSITION" in r:
        return "TRANSITION"
    if "SQUEEZE" in r or "SHORT COVER" in r:
        return "SHORT_SQUEEZE"
    if "LONG UNWIND" in r:
        return "LONG_UNWIND"
    if "DELEVERAGING" in r:
        return "DELEVERAGING"
    return "UNKNOWN"

# ----------------------------
# SETUP Detection (simple, robust)
# ----------------------------
@dataclass
class SetupSignal:
    key: str          # unique string for cooldown
    title: str        # human title
    direction: str    # LONG/SHORT
    info: str         # extra line(s)

def detect_setups(regime_key: str, kl_1m: List[List[Any]], z: Zones) -> List[SetupSignal]:
    """
    Uses last 2 candles to detect sweep+reclaim / fail patterns.
    Kline format: [open_time, open, high, low, close, ...]
    """
    if len(kl_1m) < 3:
        return []

    # last candle
    o1 = safe_float(kl_1m[-1][1]); h1 = safe_float(kl_1m[-1][2]); l1 = safe_float(kl_1m[-1][3]); c1 = safe_float(kl_1m[-1][4])
    # previous candle
    h0 = safe_float(kl_1m[-2][2]); l0 = safe_float(kl_1m[-2][3]); c0 = safe_float(kl_1m[-2][4])

    sigs: List[SetupSignal] = []

    # A) Sweep + reclaim (upper -> short)
    swept_up = (h1 > z.upper_hi) or (h0 > z.upper_hi)
    reclaimed_down = (c1 < z.upper_lo) and (h1 > z.upper_lo)
    if swept_up and reclaimed_down:
        sigs.append(SetupSignal(
            key="SWEEP_RECLAIM_SHORT",
            title="SWEEP + RECLAIM (Upper) â†’ SHORT",
            direction="SHORT",
            info=f"Upper: {fmt_int(z.upper_lo)}â€“{fmt_int(z.upper_hi)} | close={fmt_int(c1)}"
        ))

    # B) Sweep + reclaim (lower -> long)
    swept_down = (l1 < z.lower_lo) or (l0 < z.lower_lo)
    reclaimed_up = (c1 > z.lower_hi) and (l1 < z.lower_hi)
    if swept_down and reclaimed_up:
        sigs.append(SetupSignal(
            key="SWEEP_RECLAIM_LONG",
            title="SWEEP + RECLAIM (Lower) â†’ LONG",
            direction="LONG",
            info=f"Lower: {fmt_int(z.lower_lo)}â€“{fmt_int(z.lower_hi)} | close={fmt_int(c1)}"
        ))

    # C) Mean revert (RANGE only): touch zone edge then bounce back inside
    if regime_key == "RANGE":
        touch_upper = h1 >= z.upper_lo
        back_inside_upper = c1 < z.upper_lo
        if touch_upper and back_inside_upper:
            sigs.append(SetupSignal(
                key="MEAN_REVERT_SHORT",
                title="MEAN REVERT (Upper touch) â†’ SHORT",
                direction="SHORT",
                info=f"Upper_lo={fmt_int(z.upper_lo)} | close={fmt_int(c1)}"
            ))
        touch_lower = l1 <= z.lower_hi
        back_inside_lower = c1 > z.lower_hi
        if touch_lower and back_inside_lower:
            sigs.append(SetupSignal(
                key="MEAN_REVERT_LONG",
                title="MEAN REVERT (Lower touch) â†’ LONG",
                direction="LONG",
                info=f"Lower_hi={fmt_int(z.lower_hi)} | close={fmt_int(c1)}"
            ))

    return sigs

# Allowed setups by regime (hard gate)
ALLOWED_SETUPS = {
    "SHORT_SQUEEZE": {"SWEEP_RECLAIM_SHORT"},              # fade top only
    "LONG_UNWIND":   {"SWEEP_RECLAIM_LONG"},               # bounce bottom only
    "RANGE":         {"SWEEP_RECLAIM_SHORT","SWEEP_RECLAIM_LONG","MEAN_REVERT_SHORT","MEAN_REVERT_LONG"},
    "DELEVERAGING":  {"SWEEP_RECLAIM_SHORT","SWEEP_RECLAIM_LONG","MEAN_REVERT_SHORT","MEAN_REVERT_LONG"},
    "TRANSITION":    set(),
    "UNKNOWN":       set(),
}

def build_regime_message(regime: str, px15m: float, funding: float, oi15m: Optional[float], z: Zones) -> str:
    oi_s = "n/a" if oi15m is None else f"{oi15m:+.2f} (Bybit)"
    return (
        "ðŸ§­ MARKET REGIME\n"
        f"{regime}\n"
        f"px15m {fmt_pct(px15m)}, funding {funding:+.6f}, width~{z.width_pct:.2f}%\n\n"
        f"Funding: {funding:+.6f}\n"
        f"OIÎ”(15m): {oi_s}\n\n"
        f"Upper zone: {fmt_int(z.upper_lo)} â€“ {fmt_int(z.upper_hi)}\n"
        f"Lower zone: {fmt_int(z.lower_lo)} â€“ {fmt_int(z.lower_hi)}"
    )

def build_setup_message(sig: SetupSignal, regime_raw: str, z: Zones) -> str:
    return (
        "ðŸŽ¯ SETUP\n"
        f"{sig.title}\n"
        f"Regime: {regime_raw}\n\n"
        f"{sig.info}\n"
        f"Upper: {fmt_int(z.upper_lo)}â€“{fmt_int(z.upper_hi)}\n"
        f"Lower: {fmt_int(z.lower_lo)}â€“{fmt_int(z.lower_hi)}"
    )

# ----------------------------
# Main
# ----------------------------
def main() -> None:
    state = load_state()
    last_regime_sent = state.get("last_regime_sent")
    last_regime_alert_ts = float(state.get("last_regime_alert_ts", 0.0))
    last_ok_ts = float(state.get("last_ok_ts", 0.0))
    last_setup_ts: Dict[str, float] = state.get("last_setup_ts", {}) if isinstance(state.get("last_setup_ts", {}), dict) else {}

    log.info(f"Starting btc-alerts | symbol={SYMBOL} interval={INTERVAL_SEC}s | telegram={'on' if TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID else 'off'} | setups=on")

    while True:
        t0 = time.time()

        prem = binance_premium_index(SYMBOL)
        kl_1m = binance_klines(SYMBOL, "1m", 240)
        kl_15m = binance_klines(SYMBOL, "15m", 80)
        oi15m = bybit_oi_delta_15m(SYMBOL)

        if not isinstance(prem, dict) or not kl_1m or not kl_15m:
            if time.time() - last_ok_ts > 180:
                log.warning("No successful price/funding bundle for >180s (API unstable?)")
            time.sleep(INTERVAL_SEC)
            continue

        funding = safe_float(prem.get("lastFundingRate"))
        px15m = px_change_15m_from_1m(kl_1m)
        atr = atr_from_15m(kl_15m, period=14)
        z = compute_zones(kl_1m, atr=atr, lookback_min=180)

        if px15m is None or z is None or math.isnan(funding):
            time.sleep(INTERVAL_SEC)
            continue

        regime_raw = classify_regime(px15m=px15m, oi15m=oi15m, width_pct=z.width_pct)
        regime_key = norm_regime(regime_raw)

        # --- REGIME log (always)
        msg_reg = build_regime_message(regime_raw, px15m, funding, oi15m, z)
        log.info(msg_reg.replace("\n", " | "))

        # --- REGIME telegram: only on change + heartbeat
        now = time.time()
        heartbeat_sec = 600
        if (last_regime_sent != regime_raw) or (now - last_regime_alert_ts >= heartbeat_sec):
            tg_send(msg_reg)
            last_regime_sent = regime_raw
            last_regime_alert_ts = now

        # --- SETUPS
        sigs = detect_setups(regime_key=regime_key, kl_1m=kl_1m, z=z)
        allowed = ALLOWED_SETUPS.get(regime_key, set())

        for sig in sigs:
            if sig.key not in allowed:
                continue
            prev = float(last_setup_ts.get(sig.key, 0.0))
            if (now - prev) < SETUP_COOLDOWN_SEC:
                continue

            setup_msg = build_setup_message(sig, regime_raw, z)
            log.info(("SETUP | " + setup_msg.replace("\n", " | ")))
            tg_send(setup_msg)
            last_setup_ts[sig.key] = now

        # save state
        last_ok_ts = now
        save_state({
            "symbol": SYMBOL,
            "last_regime": regime_raw,
            "last_regime_sent": last_regime_sent,
            "last_regime_alert_ts": last_regime_alert_ts,
            "last_ok_ts": last_ok_ts,
            "last_setup_ts": last_setup_ts,
        })

        elapsed = time.time() - t0
        time.sleep(max(1, INTERVAL_SEC - int(elapsed)))

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        log.info("Stopped by user")
